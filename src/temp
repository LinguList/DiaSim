	
		//auxiliary for compareRuleCorrespondences, 
			// recruits proposedChs to disambiguate if a relocdation is forward or backward 
		//recall : indices in proposedChs[][0] are always the current (at point of operation) index in hypCASC -- so hi is used not bi
		private boolean relocdIsForward(int gi, int hi, int ilbi, int ilhi)
		{
			assert ilbi != -1 || ilbi != ilhi : "ERROR: called relocdIsForward() for something that cannot be a relocdation as both ilhi and ilbi are -1."; 
			if (Math.min(ilbi, ilhi) == -1)
				return ilbi == -1; 
		
			int candBackSrc = ilbi, candForwDest = ilhi;
			
			
			int pci = 0, lenpc = proposedChs.size(); 
			boolean reached = false; 
			while (!reached)
			{
				assert pci < lenpc : "ERROR: reached of end of proposedChanges without finding current target of operation."; 
				int curhi = Integer.parseInt(proposedChs.get(pci)[0]); 
				assert curhi <= hi : "ERROR: could not find current target of operation in proposedChanges!";
				reached = (curhi == hi); 
				pci ++; 
			}
			
			//PRIOR DELETION SKIPPING pass any prior deletions we have already processed wiht operations at this hyp index.
			int deletionsToPass = 0; 
			for (int pdgi = gi - 1 ; pdgi <= 0 ? true : ruleCorrespondences[1][pdgi] == -1 ; pdgi-- )
				deletionsToPass++; 
				
			pci += deletionsToPass ; 
			assert proposedChs.get(pci-1)[0].equals(""+hi) : "Error in ruleCorrespondences[1] in placement of -1 for deletion rules"; 
			assert pci < lenpc : "ERROR: reached end of proposedChanges without finding later index of relocdation operation.";
			
			boolean passed = false; 
			
			while(!passed)
			{
				// if this a deletion we then know it is forward
				if (proposedChs.get(pci-1)[1].equalsIgnoreCase("deletion"))	return true; 
				
				// now we know this is an insertion 
				// we have to make sure it isn't immediately deleted by dumb users.
				passed = !proposedChs.get(pci)[0].equals(""+hi);
				if (!passed) //it's a stupid user deleting the rule they just added, and we haven't explicitly added support on the rule processing side for this annoyance yet...
				{
					assert proposedChs.get(pci)[1].equalsIgnoreCase("deletion") : "index processing error."; 
					pci += 2;
					assert proposedChs.get(pci-1)[0].equals(""+hi) : "Error in ruleCorrespondences[1] in placement of -1 for deletion rules"; 
					assert pci < lenpc : "ERROR: reached end of proposedChanges without finding later index of relocdation operation.";
				}
			}
			// if reached this point must be an insertion, i.e. backward
			return false; 
			
			List<String[]> opsHere = new ArrayList<String[]>(); 
			
			String[] thisOp = proposedChs.get(pci - 1); 
			
			// if thisOp is a deletion:	then the next proposedCh could also have [0] = hi,
				// and that could instead be the op we are interested in, will need to disambiguate. 
			// otherwise -- we can end this here and now iff the next rule is not a deletion of the exact same spot, [hi]
			// either way we can end it immediately if the next rule's [0] is not == hi. 
			
			if ( !proposedChs.get(pci)[0].equals(""+hi) )	return thisOp[1].equalsIgnoreCase("deletion"); 
			if ( !thisOp[1].equalsIgnoreCase("deletion") ) // if we have an insertion and the next does not have same index of operation, we know next must be deletion
			{	assert proposedChs.get(pci)[1].equalsIgnoreCase("deletion") : "ERROR: indexing on proposedChs"; 
				//-- so we must return to the beginning of this loop...
				pci++;
				assert proposedChs.get(pci)[0].equals(""+hi): 
					"ERROR: could not find current target of operation in proposedChanges!";
			}
			else //we have a case of a deletion with further operation on this index
			{
				// we know that the deletion must be for the present rule as any others would be processed by PRIOR DELETION SKIPPING
				
			}			
			
			
			----
			//TODO abrogated below.
			opsHere.add(proposedChs.get(pci-1)); 
			
			boolean passed = false; 
			while (!passed)
			{
				assert pci < lenpc : "ERROR: reached end of proposedChanges without finding later index of relocdation operation.";
				if( proposedChs.get(pci)[0].equals(""+hi) )	opsHere.add(proposedChs.get(pci++));
				else	passed = true; 
			}
			
			
			// ... otherwise we have to hunt down the corresponding op of the relocdation... 
			
			boolean reached = false; 
			while (!reached) 
			{
				assert pci < lenpc : "ERROR: reached end of proposedChanges without finding later index of relocdation operation.";
			
			}
			
			
			
		
		}
	
		
		
---
		
		//now we'll test et 7, heighten, which should be changed. 
		
		//TODO continue lexical effect testing 
		
//TODO this. 




---

		 
TODO - jargon file. 

instant -- spots between rules

---

